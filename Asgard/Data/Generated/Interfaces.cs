using System;

/*  This file is automatically generated by a T4 template from a data file.
    cbus-4.0-Rev-8d-Guide-6b-opcodes
    It was last generated at 07/29/2022 20:59:12.
    Any changes made manually will be lost when the file is regenerated.
*/

namespace Asgard.Data
{
    #region Licence

/*
 *	This work is licensed under the:
 *	    Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
 *	To view a copy of this license, visit:
 *	    http://creativecommons.org/licenses/by-nc-sa/4.0/
 *	or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *	
 *	License summary:
 *	  You are free to:
 *	    Share, copy and redistribute the material in any medium or format
 *	    Adapt, remix, transform, and build upon the material
 *	
 *	  The licensor cannot revoke these freedoms as long as you follow the license terms.
 *	
 *	  Attribution : You must give appropriate credit, provide a link to the license,
 *	                 and indicate if changes were made. You may do so in any reasonable manner,
 *	                 but not in any way that suggests the licensor endorses you or your use.
 *	
 *	  NonCommercial : You may not use the material for commercial purposes. **(see note below)
 *	
 *	  ShareAlike : If you remix, transform, or build upon the material, you must distribute
 *	                your contributions under the same license as the original.
 *	
 *	  No additional restrictions : You may not apply legal terms or technological measures that
 *	                                legally restrict others from doing anything the license permits.
 *	
 *	 ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
 *	
 *	  This software is distributed in the hope that it will be useful, but WITHOUT ANY
 *	  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE

 *  */
    #endregion

    #region History

/*  Date		Author
 *	2021-11-06	Richard Crawshaw	Original from Developers' Guide for CBUS version 6b

 *  */

    #endregion

    #region Interfaces

    #region 0x00 ACK General Acknowledgement

    /// <summary>
    /// ACK
    /// General Acknowledgement
    /// Positive response to query / request performed or report of availability on-line.
    /// </summary>
    public interface IGeneralAcknowledgement
    {
    }

    #endregion

    #region 0x01 NAK General No Acknowledgement

    /// <summary>
    /// NAK
    /// General No Acknowledgement
    /// Negative response to query / request denied.
    /// </summary>
    public interface IGeneralNoAcknowledgement
    {
    }

    #endregion

    #region 0x02 HLT Bus Halt

    /// <summary>
    /// HLT
    /// Bus Halt
    /// Commonly broadcasted to all nodes to indicate CBUS is not available and no further packets should be sent until a BON or ARST is received.
    /// </summary>
    public interface IBusHalt
    {
    }

    #endregion

    #region 0x03 BON Bus On

    /// <summary>
    /// BON
    /// Bus On
    /// Commonly broadcasted to all nodes to indicate CBUS is available following a HLT.
    /// </summary>
    public interface IBusOn
    {
    }

    #endregion

    #region 0x04 TOF Track Off

    /// <summary>
    /// TOF
    /// Track Off
    /// Commonly broadcasted to all nodes by a command station to indicate track power is off and no further command packets should be sent
    /// </summary>
    public interface ITrackOff
    {
    }

    #endregion

    #region 0x05 TON Track On

    /// <summary>
    /// TON
    /// Track On
    /// Commonly broadcasted to all nodes by a command station to indicate track power is on.
    /// </summary>
    public interface ITrackOn
    {
    }

    #endregion

    #region 0x06 ESTOP Emergency Stop

    /// <summary>
    /// ESTOP
    /// Emergency Stop
    /// Commonly broadcast to all nodes by a command station to indicate all engines have been emergency stopped.
    /// </summary>
    public interface IEmergencyStop
    {
    }

    #endregion

    #region 0x07 ARST System Reset

    /// <summary>
    /// ARST
    /// System Reset
    /// Commonly broadcasted to all nodes to indicate a full system reset.
    /// </summary>
    public interface ISystemReset
    {
    }

    #endregion

    #region 0x08 RTOF Request Track Off

    /// <summary>
    /// RTOF
    /// Request Track Off
    /// Sent to request change of track power state to “off”.
    /// </summary>
    public interface IRequestTrackOff
    {
    }

    #endregion

    #region 0x09 RTON Request Track On

    /// <summary>
    /// RTON
    /// Request Track On
    /// Sent to request change of track power state to “on”.
    /// </summary>
    public interface IRequestTrackOn
    {
    }

    #endregion

    #region 0x0A RESTP Request Emergency Stop All

    /// <summary>
    /// RESTP
    /// Request Emergency Stop All
    /// Sent to request an emergency stop to all trains . Does not affect accessory control.
    /// </summary>
    public interface IRequestEmergencyStopAll
    {
    }

    #endregion

    #region 0x0C RSTAT Request Command Station Status

    /// <summary>
    /// RSTAT
    /// Request Command Station Status
    /// Sent to query the status of the command station.
    /// </summary>
    public interface IRequestCommandStationStatus
    {
    }

    #endregion

    #region 0x0D QNN Query Node Number

    /// <summary>
    /// QNN
    /// Query Node Number
    /// Sent by a node to elicit a PNN reply from each node on the bus that has a node number.
    /// </summary>
    public interface IQueryNodeNumber
    {
    }

    #endregion

    #region 0x10 RQNP Request node parameters

    /// <summary>
    /// RQNP
    /// Request node parameters
    /// Sent to a node while in ‘setup’ mode to read its parameter set.
    /// </summary>
    public interface IRequestNodeParameters
    {
    }

    #endregion

    #region 0x11 RQMN Request module name

    /// <summary>
    /// RQMN
    /// Request module name
    /// Sent by a node to request the name of the type of module that is in setup mode.
    /// </summary>
    public interface IRequestModuleName
    {
    }

    #endregion

    #region 0x21 KLOC Release Engine

    /// <summary>
    /// KLOC
    /// Release Engine
    /// Sent by a CAB to the Command Station. The engine with that Session number is removed from the active engine list.
    /// </summary>
    public interface IReleaseEngine
    {
        public byte Session { get; set; }
    }

    #endregion

    #region 0x22 QLOC Query Engine

    /// <summary>
    /// QLOC
    /// Query Engine
    /// The command station responds with PLOC if the session is assigned. Otherwise responds with ERR: engine not found.
    /// </summary>
    public interface IQueryEngine
    {
        public byte Session { get; set; }
    }

    #endregion

    #region 0x23 DKEEP Session keep alive

    /// <summary>
    /// DKEEP
    /// Session keep alive
    /// The cab sends a keep alive at regular intervals for the active session. The interval between keep alive messages must be less than the session timeout implemented by the command station.
    /// </summary>
    public interface ISessionKeepAlive
    {
        public byte Session { get; set; }
    }

    #endregion

    #region 0x30 DBG1 Debug with one data byte

    /// <summary>
    /// DBG1
    /// Debug with one data byte
    /// The data is a freeform status byte for debugging during CBUS module development. Not used during normal operation.
    /// </summary>
    public interface IDebugWithOneDataByte
    {
        public byte DebugStatus { get; set; }
    }

    #endregion

    #region 0x3F EXTC Extended opcode with no data bytes

    /// <summary>
    /// EXTC
    /// Extended opcode with no data bytes
    /// Used if the basic set of 32 OPCs is not enough. Allows an additional 256 opcodes.
    /// </summary>
    public interface IExtendedOpcodeWithNoDataBytes
    {
        public byte ExtendedOpCode { get; set; }
    }

    #endregion

    #region 0x40 RLOC Request engine session

    /// <summary>
    /// RLOC
    /// Request engine session
    /// The command station responds with (PLOC) if engine is free and is being assigned. Otherwise responds with (ERR): engine in use or (ERR:) stack full. This command is typically sent by a cab to the command station following a change of the controlled decoder address. RLOC is exactly equivalent to GLOC with all flag bits set to zero
    /// </summary>
    public interface IRequestEngineSession
    {
        public ushort Address { get; set; }
    }

    #endregion

    #region 0x41 QCON Query Consist

    /// <summary>
    /// QCON
    /// Query Consist
    /// Allows enumeration of a consist. Command station responds with PLOC if an engine exists at the specified index
    /// </summary>
    public interface IQueryConsist
    {
        public byte Consist { get; set; }
        public byte Index { get; set; }
    }

    #endregion

    #region 0x42 SNN Set Node Number

    /// <summary>
    /// SNN
    /// Set Node Number
    /// Sent by a configuration tool to assign a node number to a requesting node in response to a RQNN message. The target node must be in ‘setup’ mode.
    /// </summary>
    public interface ISetNodeNumber
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x43 ALOC Allocate loco to activity

    /// <summary>
    /// ALOC
    /// Allocate loco to activity
    /// Allocate a loco to an activity.
    /// </summary>
    public interface IAllocateLocoToActivity
    {
        public byte Session { get; set; }
        public byte AllocationCode { get; set; }
    }

    #endregion

    #region 0x44 STMOD Set CAB session mode

    /// <summary>
    /// STMOD
    /// Set CAB session mode
    /// Set the CAB session mode.
    /// </summary>
    public interface ISetCabSessionMode
    {
        public byte Session { get; set; }
        public SpeedModeEnum SpeedMode { get; set; }
        public ServiceModeEnum ServiceMode { get; set; }
        public bool SoundMode { get; set; }
    }

    #endregion

    #region 0x45 PCON Consist Engine

    /// <summary>
    /// PCON
    /// Consist Engine
    /// Adds a decoder to a consist.
    /// </summary>
    public interface IConsistEngine
    {
        public byte Consist { get; set; }
        public byte Session { get; set; }
    }

    #endregion

    #region 0x46 KCON Remove Engine from consist

    /// <summary>
    /// KCON
    /// Remove Engine from consist
    /// Removes a loco from a consist.
    /// </summary>
    public interface IRemoveEngineFromConsist
    {
        public byte Consist { get; set; }
        public byte Session { get; set; }
    }

    #endregion

    #region 0x47 DSPD Set Engine Speed and Direction

    /// <summary>
    /// DSPD
    /// Set Engine Speed and Direction
    /// Sent by a CAB or equivalent to request an engine speed/dir change.
    /// </summary>
    public interface ISetEngineSpeedAndDirection
    {
        public byte Session { get; set; }
        public byte SpeedDir { get; set; }
    }

    #endregion

    #region 0x48 DFLG Set Engine Flags

    /// <summary>
    /// DFLG
    /// Set Engine Flags
    /// Sent by a cab to notify the command station of a change in engine flags.
    /// </summary>
    public interface ISetEngineFlags
    {
        public byte Session { get; set; }
        public SpeedModeEnum SpeedMode { get; set; }
        public bool Lights { get; set; }
        public bool Direction { get; set; }
        public EngineStateEnum EngineState { get; set; }
    }

    #endregion

    #region 0x49 DFNON Set Engine function On

    /// <summary>
    /// DFNON
    /// Set Engine function On
    /// Sent by a cab to turn on a specific loco function. This provides an alternative method to DFUN for controlling loco functions. A command station must implement both methods.
    /// </summary>
    public interface ISetEngineFunctionOn
    {
        public byte Session { get; set; }
        public byte FunctionNumber { get; set; }
    }

    #endregion

    #region 0x4A DFNOF Set Engine function Off

    /// <summary>
    /// DFNOF
    /// Set Engine function Off
    /// Sent by a cab to turn off a specific loco function. This provides an alternative method to DFUN for controlling loco functions. A command station must implement both methods.
    /// </summary>
    public interface ISetEngineFunctionOff
    {
        public byte Session { get; set; }
        public byte FunctionNumber { get; set; }
    }

    #endregion

    #region 0x4C SSTAT Service mode status

    /// <summary>
    /// SSTAT
    /// Service mode status
    /// Status returned by command station/programmer at end of programming operation that does not return data.
    /// </summary>
    public interface IServiceModeStatus
    {
        public byte Session { get; set; }
        public SessionStatusEnum SessionStatus { get; set; }
    }

    #endregion

    #region 0x50 RQNN Request node number

    /// <summary>
    /// RQNN
    /// Request node number
    /// Sent by a node that is in setup/configuration mode and requests assignment of a node number (NN). The node allocating node numbers responds with (SNN) which contains the newly assigned node number. <NN hi> and <NN lo> are the existing node number
    /// </summary>
    public interface IRequestNodeNumber
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x51 NNREL Node number release

    /// <summary>
    /// NNREL
    /// Node number release
    /// Sent by node when taken out of service. e.g. when reverting to SLiM mode.
    /// </summary>
    public interface INodeNumberRelease
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x52 NNACK Node number acknowledge

    /// <summary>
    /// NNACK
    /// Node number acknowledge
    /// Sent by a node to verify its presence and confirm its node id. This message is sent to acknowledge an SNN.
    /// </summary>
    public interface INodeNumberAcknowledge
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x53 NNLRN Set node into learn mode

    /// <summary>
    /// NNLRN
    /// Set node into learn mode
    /// Sent by a configuration tool to put a specific node into learn mode.
    /// </summary>
    public interface ISetNodeIntoLearnMode
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x54 NNULN Release node from learn mode

    /// <summary>
    /// NNULN
    /// Release node from learn mode
    /// Sent by a configuration tool to take node out of learn mode and revert to normal operation.
    /// </summary>
    public interface IReleaseNodeFromLearnMode
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x55 NNCLR Clear all events from a node

    /// <summary>
    /// NNCLR
    /// Clear all events from a node
    /// Sent by a configuration tool to clear all events from a specific node. Must be in learn mode first to safeguard against accidental erasure of all events.
    /// </summary>
    public interface IClearAllEventsFromANode
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x56 NNEVN Read number of events available in a node

    /// <summary>
    /// NNEVN
    /// Read number of events available in a node
    /// Sent by a configuration tool to read the number of available event slots in a node. Response is EVLNF (0x70).
    /// </summary>
    public interface IReadNumberOfEventsAvailableInANode
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x57 NERD Read back all stored events in a node

    /// <summary>
    /// NERD
    /// Read back all stored events in a node
    /// Sent by a configuration tool to read all the stored events in a node. Response is ENRSP (0xF2).
    /// </summary>
    public interface IReadBackAllStoredEventsInANode
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x58 RQEVN Request to read number of stored events

    /// <summary>
    /// RQEVN
    /// Request to read number of stored events
    /// Sent by a configuration tool to read the number of stored events in a node. Response is NUMEV (0x74).
    /// </summary>
    public interface IRequestToReadNumberOfStoredEvents
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x59 WRACK Write acknowledge

    /// <summary>
    /// WRACK
    /// Write acknowledge
    /// Sent by a node to indicate the completion of a write to memory operation. All nodes must issue WRACK when a write operation to node variables
    /// </summary>
    public interface IWriteAcknowledge
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x5A RQDAT Request node data event

    /// <summary>
    /// RQDAT
    /// Request node data event
    /// Sent by one node to read the data event from another node.(eg: RFID data). Response is ARDAT (0xF7).
    /// </summary>
    public interface IRequestNodeDataEvent
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x5B RQDDS Request device data - short mode

    /// <summary>
    /// RQDDS
    /// Request device data - short mode
    /// To request a ‘data set’ from a device using the short event method. where DN is the device number. Response is DDRS (0xFB).
    /// </summary>
    public interface IRequestDeviceDataShortMode
    {
        public ushort DeviceNumber { get; set; }
    }

    #endregion

    #region 0x5C BOOTM Put node into bootload mode

    /// <summary>
    /// BOOTM
    /// Put node into bootload mode
    /// For SliM nodes with no NN then the NN of the command is must be zero. For SLiM nodes with an NN
    /// </summary>
    public interface IPutNodeIntoBootloadMode
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x5D ENUM Force a self enumeration cycle for use with CAN

    /// <summary>
    /// ENUM
    /// Force a self enumeration cycle for use with CAN
    /// For nodes in FLiM using CAN as transport. This OPC will force a self-enumeration cycle for the specified node. A new CAN_ID will be allocated if needed. Following the ENUM sequence
    /// </summary>
    public interface IForceASelfEnumerationCycleForUseWithCan
    {
        public ushort NodeNumber { get; set; }
    }

    #endregion

    #region 0x5F EXTC1 Extended opcode with 1 data byte

    /// <summary>
    /// EXTC1
    /// Extended opcode with 1 data byte
    /// Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs.
    /// </summary>
    public interface IExtendedOpcodeWith1DataByte
    {
        public byte ExtendedOpCode { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0x60 DFUN Set Engine functions

    /// <summary>
    /// DFUN
    /// Set Engine functions
    /// Sent by a CAB or equivalent to request an engine Fn state change.
    /// </summary>
    public interface ISetEngineFunctions
    {
        public byte Session { get; set; }
        public FunctionRangeEnum FunctionRange { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x61 GLOC Get engine session

    /// <summary>
    /// GLOC
    /// Get engine session
    /// Otherwise responds with (ERR): engine in use. (ERR:) stack full or (ERR) no session. The latter indicates that there is no current session to steal/share depending on the flag bits set in the request./r/nGLOC with all flag bits set to zero is exactly equivalent to RLOC
    /// </summary>
    public interface IGetEngineSession
    {
        public ushort Address { get; set; }
        public SessionFlagsEnum SessionFlags { get; set; }
    }

    #endregion

    #region 0x63 ERR Command Station Error report

    /// <summary>
    /// ERR
    /// Command Station Error report
    /// Sent in response to an error situation by a command station.
    /// </summary>
    public interface ICommandStationErrorReport
    {
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public DccErrorCodeEnum DccErrorCode { get; set; }
    }

    #endregion

    #region 0x6F CMDERR Error messages from nodes during configuration

    /// <summary>
    /// CMDERR
    /// Error messages from nodes during configuration
    /// Sent by node if there is an error when a configuration command is sent.
    /// </summary>
    public interface IErrorMessagesFromNodesDuringConfiguration
    {
        public ushort NodeNumber { get; set; }
        public AccErrorCodeEnum AccErrorCode { get; set; }
    }

    #endregion

    #region 0x70 EVNLF Event space left reply from node

    /// <summary>
    /// EVNLF
    /// Event space left reply from node
    /// The number of available events left in that node.
    /// </summary>
    public interface IEventSpaceLeftReplyFromNode
    {
        public ushort NodeNumber { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x71 NVRD Request read of a node variable

    /// <summary>
    /// NVRD
    /// Request read of a node variable
    /// Response is NVANS (0x97).
    /// </summary>
    public interface IRequestReadOfANodeVariable
    {
        public ushort NodeNumber { get; set; }
        public byte NVIndex { get; set; }
    }

    #endregion

    #region 0x72 NENRD Request read of stored events by event index

    /// <summary>
    /// NENRD
    /// Request read of stored events by event index
    /// Response is ENRSP (0xF2).
    /// </summary>
    public interface IRequestReadOfStoredEventsByEventIndex
    {
        public ushort NodeNumber { get; set; }
        public byte ENIndex { get; set; }
    }

    #endregion

    #region 0x73 RQNPN Request read of a node parameter by index

    /// <summary>
    /// RQNPN
    /// Request read of a node parameter by index
    /// Response is PARAN (0x9B).
    /// </summary>
    public interface IRequestReadOfANodeParameterByIndex
    {
        public ushort NodeNumber { get; set; }
        public byte ParamIndex { get; set; }
    }

    #endregion

    #region 0x74 NUMEV Number of events stored in node

    /// <summary>
    /// NUMEV
    /// Number of events stored in node
    /// Response to request RQEVN (0x58).
    /// </summary>
    public interface INumberOfEventsStoredInNode
    {
        public ushort NodeNumber { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x75 CANID Set a CAN_ID in existing FLiM node

    /// <summary>
    /// CANID
    /// Set a CAN_ID in existing FLiM node
    /// Used to force a specified CAN_ID into a node. Value range is from 1 to 0x63 (99 decimal) This OPC must be used with care as duplicate CAN_IDs are not allowed.. Values outside the permitted range will produce an error 7 message.and the CAN_ID will not change.
    /// </summary>
    public interface ISetACan_idInExistingFlimNode
    {
        public ushort NodeNumber { get; set; }
        public byte CAN_ID { get; set; }
    }

    #endregion

    #region 0x7F EXTC2 Extended opcode with 2 data bytes

    /// <summary>
    /// EXTC2
    /// Extended opcode with 2 data bytes
    /// Used if the basic set of 32 OPCs is not enough. Allows an additional 256 opcodes.
    /// </summary>
    public interface IExtendedOpcodeWith2DataBytes
    {
        public byte ExtendedOpCode { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0x80 RDCC3 Request 3 byte DCC Packet

    /// <summary>
    /// RDCC3
    /// Request 3 byte DCC Packet
    /// Allows a CAB or equivalent to request a 3 byte DCC packet to be sent to the track. The packet is sent <REP> times and is not refreshed on a regular basis. Note: a 3 byte DCC packet is the minimum allowed.
    /// </summary>
    public interface IRequest3ByteDccPacket
    {
        public byte Repetitions { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0x82 WCVO Write CV (byte) in OPS mode

    /// <summary>
    /// WCVO
    /// Write CV (byte) in OPS mode
    /// Sent to the command station to write a DCC CV byte in OPS mode to specific loco.(on the main).
    /// </summary>
    public interface IWriteCvByteInOpsMode
    {
        public byte Session { get; set; }
        public ushort CV { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x83 WCVB Write CV (bit) in OPS mode

    /// <summary>
    /// WCVB
    /// Write CV (bit) in OPS mode
    /// Sent to the command station to write a DCC CV in OPS mode to specific loco.(on the main).
    /// </summary>
    public interface IWriteCvBitInOpsMode
    {
        public byte Session { get; set; }
        public ushort CV { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x84 QCVS Read CV

    /// <summary>
    /// QCVS
    /// Read CV
    /// This command is used exclusively with service mode. Sent by the cab to the command station in order to read a CV value. The command station shall respond with a PCVS message containing the value read
    /// </summary>
    public interface IReadCv
    {
        public byte Session { get; set; }
        public ushort CV { get; set; }
        public ServiceModeEnum ServiceMode { get; set; }
    }

    #endregion

    #region 0x85 PCVS Report CV

    /// <summary>
    /// PCVS
    /// Report CV
    /// This command is used exclusively with service mode. Sent by the command station to report a read CV.
    /// </summary>
    public interface IReportCv
    {
        public byte Session { get; set; }
        public ushort CV { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x90 ACON Accessory On

    /// <summary>
    /// ACON
    /// Accessory On
    /// Indicates an ‘ON’ event using the full event number of 4 bytes. (long event).
    /// </summary>
    public interface IAccessoryOn
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
    }

    #endregion

    #region 0x91 ACOF Accessory Off

    /// <summary>
    /// ACOF
    /// Accessory Off
    /// Indicates an ‘OFF’ event using the full event number of 4 bytes. (long event).
    /// </summary>
    public interface IAccessoryOff
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
    }

    #endregion

    #region 0x92 AREQ Accessory Request Event

    /// <summary>
    /// AREQ
    /// Accessory Request Event
    /// Indicates a ‘request’ event using the full event number of 4 bytes. (long event)./r/nA request event is used to elicit a status response from a producer when it is required to know the ‘state’ of the producer without producing an ON or OFF event and to trigger an event from a ‘combi’ node.
    /// </summary>
    public interface IAccessoryRequestEvent
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
    }

    #endregion

    #region 0x93 ARON Accessory On Response Event

    /// <summary>
    /// ARON
    /// Accessory On Response Event
    /// Indicates an ‘ON’ response event. A response event is a reply to a status request AREQ (0x92) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryOnResponseEvent
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
    }

    #endregion

    #region 0x94 AROF Accessory Off Response Event

    /// <summary>
    /// AROF
    /// Accessory Off Response Event
    /// Indicates an ‘OFF’ response event. A response event is a reply to a status request AREQ (0x92) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryOffResponseEvent
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
    }

    #endregion

    #region 0x95 EVULN Unlearn an event in learn mode

    /// <summary>
    /// EVULN
    /// Unlearn an event in learn mode
    /// Sent by a configuration tool to remove an event from a node.
    /// </summary>
    public interface IUnlearnAnEventInLearnMode
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
    }

    #endregion

    #region 0x96 NVSET Set a node variable

    /// <summary>
    /// NVSET
    /// Set a node variable
    /// Sent by a configuration tool to set a node variable.
    /// </summary>
    public interface ISetANodeVariable
    {
        public ushort NodeNumber { get; set; }
        public byte NVIndex { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x97 NVANS Response to a request for a node variable value

    /// <summary>
    /// NVANS
    /// Response to a request for a node variable value
    /// Sent by node in response to request NVRD (0x71).
    /// </summary>
    public interface IResponseToARequestForANodeVariableValue
    {
        public ushort NodeNumber { get; set; }
        public byte NVIndex { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x98 ASON Accessory Short On

    /// <summary>
    /// ASON
    /// Accessory Short On
    /// Indicates an ‘ON’ event using the short event number of 2 LS bytes.
    /// </summary>
    public interface IAccessoryShortOn
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
    }

    #endregion

    #region 0x99 ASOF Accessory Short Off

    /// <summary>
    /// ASOF
    /// Accessory Short Off
    /// Indicates an ‘OFF’ event using the short event number of 2 LS bytes.
    /// </summary>
    public interface IAccessoryShortOff
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
    }

    #endregion

    #region 0x9A ASRQ Accessory Short Request Event

    /// <summary>
    /// ASRQ
    /// Accessory Short Request Event
    /// Indicates a ‘request’ event using the short event number of 2 LS bytes. A request event is used to elicit a response from a producer ‘device’ when it is required to know the ‘state’ of the device without producing an ON or OFF event and to trigger an event from a “combi” node.
    /// </summary>
    public interface IAccessoryShortRequestEvent
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
    }

    #endregion

    #region 0x9B PARAN Response to request for individual node parameter

    /// <summary>
    /// PARAN
    /// Response to request for individual node parameter
    /// The response to a request for an individual node parameter.
    /// </summary>
    public interface IResponseToRequestForIndividualNodeParameter
    {
        public ushort NodeNumber { get; set; }
        public byte ParamIndex { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0x9C REVAL Request for read of an event variable

    /// <summary>
    /// REVAL
    /// Request for read of an event variable
    /// This request differs from REQEV (0xB2) as it doesn’t need to be in learn mode but does require the knowledge of the event index to which the EV request is directed. Response is NEVAL (0xB5).
    /// </summary>
    public interface IRequestForReadOfAnEventVariable
    {
        public ushort NodeNumber { get; set; }
        public byte ENIndex { get; set; }
        public byte EVIndex { get; set; }
    }

    #endregion

    #region 0x9D ARSON Accessory Short Response On

    /// <summary>
    /// ARSON
    /// Accessory Short Response On
    /// Indicates an ‘ON’ response event. A response event is a reply to a status request ASRQ (0x9A) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryShortResponseOn
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
    }

    #endregion

    #region 0x9E ARSOF Accessory Short Response Off

    /// <summary>
    /// ARSOF
    /// Accessory Short Response Off
    /// Indicates an ‘OFF’ response event. A response event is a reply to a status request ASRQ (0x9A) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryShortResponseOff
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
    }

    #endregion

    #region 0x9F EXTC3 Extended opcode with 3 data bytes

    /// <summary>
    /// EXTC3
    /// Extended opcode with 3 data bytes
    /// Used if the basic set of 32 OPCs is not enough. Allows an additional 256 opcodes.
    /// </summary>
    public interface IExtendedOpcodeWith3DataBytes
    {
        public byte ExtendedOpCode { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xA0 RDCC4 Request 4 byte DCC Packet

    /// <summary>
    /// RDCC4
    /// Request 4 byte DCC Packet
    /// Allows a CAB or equivalent to request a 4 byte DCC packet to be sent to the track. The packet is sent <REP> times and is not refreshed on a regular basis.
    /// </summary>
    public interface IRequest4ByteDccPacket
    {
        public byte Repetitions { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
    }

    #endregion

    #region 0xA2 WCVS Write CV in Service mode

    /// <summary>
    /// WCVS
    /// Write CV in Service mode
    /// Sent to the command station to write a DCC CV in service mode.
    /// </summary>
    public interface IWriteCvInServiceMode
    {
        public byte Session { get; set; }
        public ushort CV { get; set; }
        public ServiceModeEnum ServiceMode { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0xB0 ACON1 Accessory On 1

    /// <summary>
    /// ACON1
    /// Accessory On 1
    /// Indicates an ‘ON’ event using the full event number of 4 bytes with one additional data byte.
    /// </summary>
    public interface IAccessoryOn1
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0xB1 ACOF1 Accessory Off 1

    /// <summary>
    /// ACOF1
    /// Accessory Off 1
    /// Indicates an ‘OFF’ event using the full event number of 4 bytes with one additional data byte.
    /// </summary>
    public interface IAccessoryOff1
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0xB2 REQEV Read event variable in learn mode

    /// <summary>
    /// REQEV
    /// Read event variable in learn mode
    /// Allows a configuration tool to read stored event variables from a node. Reply is EVANS (0xD3).
    /// </summary>
    public interface IReadEventVariableInLearnMode
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte EVIndex { get; set; }
    }

    #endregion

    #region 0xB3 ARON1 Accessory On Response Event 1

    /// <summary>
    /// ARON1
    /// Accessory On Response Event 1
    /// Indicates an ‘ON’ response event with one additional data byte. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryOnResponseEvent1
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0xB4 AROF1 Accessory Off Response Event 1

    /// <summary>
    /// AROF1
    /// Accessory Off Response Event 1
    /// Indicates an ‘OFF’ response event with one additional data byte. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryOffResponseEvent1
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0xB5 NEVAL Response to request for read of EV value

    /// <summary>
    /// NEVAL
    /// Response to request for read of EV value
    /// This is response to REVAL (0x9C).
    /// </summary>
    public interface IResponseToRequestForReadOfEvValue
    {
        public ushort NodeNumber { get; set; }
        public byte EVIndex { get; set; }
        public byte ENIndex { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0xB6 PNN Response to Query Node

    /// <summary>
    /// PNN
    /// Response to Query Node
    /// Every node should send this message in response to a QNN (0x0D) message.
    /// </summary>
    public interface IResponseToQueryNode
    {
        public ushort NodeNumber { get; set; }
        public byte ManufId { get; set; }
        public byte ModuleId { get; set; }
        public NodeFlagsEnum NodeFlags { get; set; }
    }

    #endregion

    #region 0xB8 ASON1 Accessory Short On 1

    /// <summary>
    /// ASON1
    /// Accessory Short On 1
    /// Indicates an ‘ON’ event using the short event number of 2 LS bytes with one added data byte.
    /// </summary>
    public interface IAccessoryShortOn1
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0xB9 ASOF1 Accessory Short Off 1

    /// <summary>
    /// ASOF1
    /// Accessory Short Off 1
    /// Indicates an ‘OFF’ event using the short event number of 2 LS bytes with one added data byte.
    /// </summary>
    public interface IAccessoryShortOff1
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0xBD ARSON1 Accessory Short Response On 1

    /// <summary>
    /// ARSON1
    /// Accessory Short Response On 1
    /// Indicates an ‘ON’ response event with one added data byte. A response event is a reply to a status request ASRQ (0x9A) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryShortResponseOn1
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0xBE ARSOF1 Accessory Short Response Off 1

    /// <summary>
    /// ARSOF1
    /// Accessory Short Response Off 1
    /// Indicates an ‘OFF’ response event with one added data byte. A response event is a reply to a status request ASRQ (0x9A) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryShortResponseOff1
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
    }

    #endregion

    #region 0xBF EXTC4 Extended opcode with 4 data bytes

    /// <summary>
    /// EXTC4
    /// Extended opcode with 4 data bytes
    /// Used if the basic set of 32 OPCs is not enough. Allows an additional 256 opcodes.
    /// </summary>
    public interface IExtendedOpcodeWith4DataBytes
    {
        public byte ExtendedOpCode { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
    }

    #endregion

    #region 0xC0 RDCC5 Request 5 byte DCC Packet

    /// <summary>
    /// RDCC5
    /// Request 5 byte DCC Packet
    /// Allows a CAB or equivalent to request a 5 byte DCC packet to be sent to the track. The packet is sent <REP> times and is not refreshed on a regular basis.
    /// </summary>
    public interface IRequest5ByteDccPacket
    {
        public byte Repetitions { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
        public byte Data5 { get; set; }
    }

    #endregion

    #region 0xC1 WCVOA Write CV (byte) in OPS mode by address

    /// <summary>
    /// WCVOA
    /// Write CV (byte) in OPS mode by address
    /// Sent to the command station to write a DCC CV byte in OPS mode to specific loco (on the main). Used by computer based ops mode programmer that does not have a valid throttle handle.
    /// </summary>
    public interface IWriteCvByteInOpsModeByAddress
    {
        public ushort Address { get; set; }
        public ushort CV { get; set; }
        public byte Mode { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0xCF FCLK Fast Clock

    /// <summary>
    /// FCLK
    /// Fast Clock
    /// Used to implement a fast clock for the layout.
    /// </summary>
    public interface IFastClock
    {
        public byte Minutes { get; set; }
        public byte Hours { get; set; }
        public WeekdayEnum Weekday { get; set; }
        public MonthEnum Month { get; set; }
        public byte Div { get; set; }
        public byte MonthDay { get; set; }
        public byte Temperature { get; set; }
    }

    #endregion

    #region 0xD0 ACON2 Accessory On 2

    /// <summary>
    /// ACON2
    /// Accessory On 2
    /// Indicates an ‘ON’ event using the full event number of 4 bytes with two additional data bytes.
    /// </summary>
    public interface IAccessoryOn2
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0xD1 ACOF2 Accessory Off 2

    /// <summary>
    /// ACOF2
    /// Accessory Off 2
    /// Indicates an ‘OFF’ event using the full event number of 4 bytes with two additional data bytes.
    /// </summary>
    public interface IAccessoryOff2
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0xD2 EVLRN Teach an event in learn mode

    /// <summary>
    /// EVLRN
    /// Teach an event in learn mode
    /// Sent by a configuration tool to a node in learn mode to teach it an event. Also teaches it the associated event variables (EVs) by the EV index (EV#). This command is repeated for each EV required.
    /// </summary>
    public interface ITeachAnEventInLearnMode
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte EVIndex { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0xD3 EVANS Response to a request for an EV value in a node in learn mode

    /// <summary>
    /// EVANS
    /// Response to a request for an EV value in a node in learn mode
    /// A node response to a request from a configuration tool for the EVs associated with an event REQEV (0xB2). For multiple EVs
    /// </summary>
    public interface IResponseToARequestForAnEvValueInANodeInLearnMode
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte EVIndex { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0xD4 ARON2 Accessory On Response Event 2

    /// <summary>
    /// ARON2
    /// Accessory On Response Event 2
    /// Indicates an ‘ON’ response event with two added data bytes. A response event is a reply to a status request AREQ (0x92) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryOnResponseEvent2
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0xD5 AROF2 Accessory Off Response Event 2

    /// <summary>
    /// AROF2
    /// Accessory Off Response Event 2
    /// Indicates an ‘OFF’ response event with two added data bytes. A response event is a reply to a status request AREQ (0x92) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryOffResponseEvent2
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0xD8 ASON2 Accessory Short On 2

    /// <summary>
    /// ASON2
    /// Accessory Short On 2
    /// Indicates an ‘ON’ event using the short event number of 2 LS bytes with two added data bytes.
    /// </summary>
    public interface IAccessoryShortOn2
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0xD9 ASOF2 Accessory Short Off 2

    /// <summary>
    /// ASOF2
    /// Accessory Short Off 2
    /// Indicates an ‘OFF’ event using the short event number of 2 LS bytes with two added data bytes.
    /// </summary>
    public interface IAccessoryShortOff2
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0xDD ARSON2 Accessory Short Response On 2

    /// <summary>
    /// ARSON2
    /// Accessory Short Response On 2
    /// Indicates an ‘ON’ response event with two added data bytes. A response event is a reply to a status request ASRQ (0x9A) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryShortResponseOn2
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0xDE ARSOF2 Accessory Short Response Off 2

    /// <summary>
    /// ARSOF2
    /// Accessory Short Response Off 2
    /// Indicates an ‘OFF’ response event with two added data bytes. A response event is a reply to a status request ASRQ (0x9A) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryShortResponseOff2
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
    }

    #endregion

    #region 0xDF EXTC5 Extended opcode with 5 data bytes

    /// <summary>
    /// EXTC5
    /// Extended opcode with 5 data bytes
    /// Used if the basic set of 32 OPCs is not enough. Allows an additional 256 opcodes.
    /// </summary>
    public interface IExtendedOpcodeWith5DataBytes
    {
        public byte ExtendedOpCode { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
        public byte Data5 { get; set; }
    }

    #endregion

    #region 0xE0 RDCC6 Request 6 byte DCC packet

    /// <summary>
    /// RDCC6
    /// Request 6 byte DCC packet
    /// Allows a CAB or equivalent to request a 6 byte DCC packet to be sent to the track. The packet is sent <REP> times and is not refreshed on a regular basis.
    /// </summary>
    public interface IRequest6ByteDccPacket
    {
        public byte Repetitions { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
        public byte Data5 { get; set; }
        public byte Data6 { get; set; }
    }

    #endregion

    #region 0xE1 PLOC Engine report

    /// <summary>
    /// PLOC
    /// Engine report
    /// A report of an engine entry sent by the command station. Sent in response to QLOC (0x22) or as an acknowledgement of acquiring an engine requested by a cab (RLOC (0x40) or GLOC (0x61)).
    /// </summary>
    public interface IEngineReport
    {
        public byte Session { get; set; }
        public ushort Address { get; set; }
        public byte SpeedDir { get; set; }
        public byte Fn1 { get; set; }
        public byte Fn2 { get; set; }
        public byte Fn3 { get; set; }
    }

    #endregion

    #region 0xE2 NAME Response to request for node name string

    /// <summary>
    /// NAME
    /// Response to request for node name string
    /// A node response while in ‘setup’ mode for its name string. Reply to RQMN (0x11). The Module Name prefix
    /// </summary>
    public interface IResponseToRequestForNodeNameString
    {
        public char Char1 { get; set; }
        public char Char2 { get; set; }
        public char Char3 { get; set; }
        public char Char4 { get; set; }
        public char Char5 { get; set; }
        public char Char6 { get; set; }
        public char Char7 { get; set; }
    }

    #endregion

    #region 0xE3 STAT Command Station status report

    /// <summary>
    /// STAT
    /// Command Station status report
    /// Sent by the command station in response to RSTAT (0x0C).
    /// </summary>
    public interface ICommandStationStatusReport
    {
        public ushort NodeNumber { get; set; }
        public byte CSNumber { get; set; }
        public CSFlagsEnum CSFlags { get; set; }
        public byte Major { get; set; }
        public byte Minor { get; set; }
        public byte Build { get; set; }
    }

    #endregion

    #region 0xEF PARAMS Response to request for node parameters

    /// <summary>
    /// PARAMS
    /// Response to request for node parameters
    /// A node response while in ‘setup’ mode for its parameter string. Reply to RQNP (0x10).
    /// </summary>
    public interface IResponseToRequestForNodeParameters
    {
        public byte Param1 { get; set; }
        public byte Param2 { get; set; }
        public byte Param3 { get; set; }
        public byte Param4 { get; set; }
        public byte Param5 { get; set; }
        public byte Param6 { get; set; }
        public byte Param7 { get; set; }
    }

    #endregion

    #region 0xF0 ACON3 Accessory On 3

    /// <summary>
    /// ACON3
    /// Accessory On 3
    /// Indicates an ‘ON’ event using the full event number of 4 bytes with three additional data bytes.
    /// </summary>
    public interface IAccessoryOn3
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xF1 ACOF3 Accessory Off 3

    /// <summary>
    /// ACOF3
    /// Accessory Off 3
    /// Indicates an ‘OFF’ event using the full event number of 4 bytes with three additional data bytes.
    /// </summary>
    public interface IAccessoryOff3
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xF2 ENRSP Response to request to read node events

    /// <summary>
    /// ENRSP
    /// Response to request to read node events
    /// This is a response to either NERD (0x57) or NENRD (0x72).
    /// </summary>
    public interface IResponseToRequestToReadNodeEvents
    {
        public ushort NodeNumber { get; set; }
        public uint EventData { get; set; }
        public byte ENIndex { get; set; }
    }

    #endregion

    #region 0xF3 ARON3 Accessory On Response Event 3

    /// <summary>
    /// ARON3
    /// Accessory On Response Event 3
    /// Indicates an ‘ON’ response event with three added data bytes. A response event is a reply to a status request AREQ (0x92) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryOnResponseEvent3
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xF4 AROF3 Accessory Off Response Event 3

    /// <summary>
    /// AROF3
    /// Accessory Off Response Event 3
    /// Indicates an ‘OFF’ response event with three added data bytes. A response event is a reply to a status request AREQ (0x92) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryOffResponseEvent3
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xF5 EVLRNI Teach an event in learn mode using event indexing

    /// <summary>
    /// EVLRNI
    /// Teach an event in learn mode using event indexing
    /// Sent by a configuration tool to a node in learn mode to teach it an event. The event index must be known. Also teaches it the associated event variables.(EVs). This command is repeated for each EV required.
    /// </summary>
    public interface ITeachAnEventInLearnModeUsingEventIndexing
    {
        public ushort NodeNumber { get; set; }
        public ushort EventNumber { get; set; }
        public byte ENIndex { get; set; }
        public byte EVIndex { get; set; }
        public byte Value { get; set; }
    }

    #endregion

    #region 0xF6 ACDAT Accessory node data event

    /// <summary>
    /// ACDAT
    /// Accessory node data event
    /// Indicates an event from this node with 5 bytes of data. For example
    /// </summary>
    public interface IAccessoryNodeDataEvent
    {
        public ushort NodeNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
        public byte Data5 { get; set; }
    }

    #endregion

    #region 0xF7 ARDAT Accessory node data Response

    /// <summary>
    /// ARDAT
    /// Accessory node data Response
    /// Indicates a node data response. A response event is a reply to a status request RQDAT (0x5A) without producing a new data event.
    /// </summary>
    public interface IAccessoryNodeDataResponse
    {
        public ushort NodeNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
        public byte Data5 { get; set; }
    }

    #endregion

    #region 0xF8 ASON3 Accessory Short On 3

    /// <summary>
    /// ASON3
    /// Accessory Short On 3
    /// Indicates an ‘ON’ event using the short event number of 2 LS bytes with three added data bytes.
    /// </summary>
    public interface IAccessoryShortOn3
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xF9 ASOF3 Accessory Short Off 3

    /// <summary>
    /// ASOF3
    /// Accessory Short Off 3
    /// Indicates an ‘OFF’ event using the short event number of 2 LS bytes with three added data bytes.
    /// </summary>
    public interface IAccessoryShortOff3
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xFA DDES Device data event (short mode)

    /// <summary>
    /// DDES
    /// Device data event (short mode)
    /// Function is the same as ACDAT (0xF6) but uses device addressing so can relate data to a device attached to a node. e.g. one of several RFID readers attached to a single node.
    /// </summary>
    public interface IDeviceDataEventShortMode
    {
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
        public byte Data5 { get; set; }
    }

    #endregion

    #region 0xFB DDRS Device data response (short mode)

    /// <summary>
    /// DDRS
    /// Device data response (short mode)
    /// The response to a request for data from a device RQDDS (0x5B).
    /// </summary>
    public interface IDeviceDataResponseShortMode
    {
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
        public byte Data5 { get; set; }
    }

    #endregion

    #region 0xFD ARSON3 Accessory Short Response On 3

    /// <summary>
    /// ARSON3
    /// Accessory Short Response On 3
    /// Indicates an ‘ON’ response event with with three added data bytes. A response event is a reply to a status request ASRQ (0x9A) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryShortResponseOn3
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xFE ARSOF3 Accessory Short Response Off 3

    /// <summary>
    /// ARSOF3
    /// Accessory Short Response Off 3
    /// Indicates an ‘OFF’ response event with with three added data bytes. A response event is a reply to a status request ASRQ (0x9A) without producing an ON or OFF event.
    /// </summary>
    public interface IAccessoryShortResponseOff3
    {
        public ushort NodeNumber { get; set; }
        public ushort DeviceNumber { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
    }

    #endregion

    #region 0xFF EXTC6 Extended opcode with 6 data bytes

    /// <summary>
    /// EXTC6
    /// Extended opcode with 6 data bytes
    /// Used if the basic set of 32 OPCs is not enough. Allows an additional 256 opcodes.
    /// </summary>
    public interface IExtendedOpcodeWith6DataBytes
    {
        public byte ExtendedOpCode { get; set; }
        public byte Data1 { get; set; }
        public byte Data2 { get; set; }
        public byte Data3 { get; set; }
        public byte Data4 { get; set; }
        public byte Data5 { get; set; }
        public byte Data6 { get; set; }
    }

    #endregion

    #endregion
}
